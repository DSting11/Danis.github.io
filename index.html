<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Avoide - Kelompok 3</title>
    
    <!-- AUDIO ELEMENTS -->
    <audio id="bgmMenu" loop preload="auto">
        <source src="music/menu.mp3" type="audio/mpeg">
        <source src="music/menu.ogg" type="audio/ogg">
    </audio>
    <audio id="bgmNormal" loop preload="auto">
        <source src="music/normal.mp3" type="audio/mpeg">
        <source src="music/normal.ogg" type="audio/ogg">
    </audio>
    <audio id="bgmBoss" loop preload="auto">
        <source src="music/boss.mp3" type="audio/mpeg">
        <source src="music/boss.ogg" type="audio/ogg">
    </audio>
    <!-- SFX hanya untuk Click (hover dihapus) -->
    <audio id="sfxClick" preload="auto">
        <source src="sfx/click.mp3" type="audio/mpeg">
    </audio>

    <style>
        :root {
            --bg-primary: #ffffff;
            --color-primary: #000000;
            --color-dim: #666666;
            --color-success: #00aa00;
            --color-danger: #ff0000;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #ffffff;
            color: var(--color-primary);
            overflow: hidden;
            height: 100vh;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(0, 0, 0, 0.3);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        @keyframes strong-pulse {
            0%, 100% { text-shadow: 0 0 20px rgba(0,0,0,0.3); transform: scale(1); }
            50% { text-shadow: 0 0 30px rgba(0,0,0,0.5); transform: scale(1.02); }
        }

        @keyframes fade-in { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); } 20%, 40%, 60%, 80% { transform: translateX(5px); } }
        @keyframes slide-up { from { transform: translateY(50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes countdown-pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
        @keyframes boost-pulse { 0%, 100% { box-shadow: 0 0 0 0 rgba(0,255,0,0.4); } 50% { box-shadow: 0 0 20px 5px rgba(0,255,0,0.2); } }

        #main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            background: radial-gradient(circle at center, rgba(240,240,240,0.95) 0%, rgba(255,255,255,0.98) 100%);
            transition: opacity 0.8s ease, visibility 0.8s ease;
        }

        #main-menu.hidden { opacity: 0; visibility: hidden; pointer-events: none; }

        .menu-header { text-align: center; margin-bottom: 40px; animation: slide-up 0.8s ease-out; }
        .game-title { font-size: 80px; font-weight: 900; letter-spacing: 8px; color: var(--color-primary); text-transform: uppercase; animation: strong-pulse 3s infinite; }
        .game-subtitle { font-size: 24px; color: var(--color-dim); letter-spacing: 4px; text-transform: uppercase; margin-bottom: 30px; }

        .menu-buttons { display: flex; flex-direction: column; gap: 15px; width: 320px; }
        
        .menu-btn, .boost-selected-display, .back-btn {
            padding: 18px 40px;
            font-size: 18px;
            color: var(--color-primary);
            background: transparent;
            border: 2px solid rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            font-weight: 600;
            position: relative;
            overflow: hidden;
        }

        .menu-btn:hover, .back-btn:hover {
            background: rgba(0, 0, 0, 0.05);
            border-color: var(--color-primary);
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }

        .boost-selected-display {
            background: rgba(0, 255, 0, 0.1);
            border-color: var(--color-success);
            font-size: 14px;
            padding: 10px;
            text-align: center;
        }

        #credits-screen, #boost-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            background: rgba(255, 255, 255, 0.98);
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        #credits-screen.active, #boost-screen.active { display: flex; opacity: 1; }

        .screen-title { font-size: 48px; margin-bottom: 40px; text-transform: uppercase; letter-spacing: 6px; }

        .boost-grid {
            display: flex;
            gap: 30px;
            margin-bottom: 40px;
        }

        .boost-card {
            width: 200px;
            padding: 30px 20px;
            border: 2px solid rgba(0,0,0,0.2);
            border-radius: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(255,255,255,0.5);
        }

        .boost-card:hover {
            transform: translateY(-5px);
            border-color: var(--color-primary);
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
        }

        .boost-card.selected {
            background: rgba(0, 255, 0, 0.1);
            border-color: var(--color-success);
            box-shadow: 0 0 20px rgba(0,255,0,0.3);
        }

        .boost-icon { font-size: 48px; margin-bottom: 15px; }
        .boost-name { font-size: 20px; font-weight: 700; margin-bottom: 10px; text-transform: uppercase; }
        .boost-desc { font-size: 12px; color: var(--color-dim); line-height: 1.4; }

        #game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            transition: opacity 1s ease;
        }

        #game-ui.active { opacity: 1; }

        .hud-panel { position: absolute; padding: 20px; pointer-events: auto; }
        .health-panel { top: 20px; right: 20px; width: 250px; }
        
        .boost-panel {
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 15px;
            background: rgba(255,255,255,0.9);
            padding: 15px 25px;
            border-radius: 30px;
            border: 2px solid rgba(0,0,0,0.2);
        }

        .boost-key {
            width: 40px;
            height: 40px;
            border: 2px solid var(--color-primary);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            font-size: 20px;
            background: rgba(0,0,0,0.05);
        }

        .boost-key.ready { animation: boost-pulse 1.5s infinite; background: rgba(0,255,0,0.2); border-color: var(--color-success); }
        .boost-key.cooldown { opacity: 0.5; background: rgba(255,0,0,0.1); border-color: var(--color-danger); }

        .boost-info { display: flex; flex-direction: column; }
        .boost-type { font-size: 14px; font-weight: 700; text-transform: uppercase; }
        .boost-status { font-size: 11px; color: var(--color-dim); }

        .cooldown-bar {
            width: 100px;
            height: 4px;
            background: rgba(0,0,0,0.1);
            border-radius: 2px;
            margin-top: 5px;
            overflow: hidden;
        }

        .cooldown-fill {
            height: 100%;
            background: var(--color-success);
            transition: width 0.1s linear;
        }

        .countdown-panel {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        .countdown-display {
            font-size: 48px;
            font-weight: 900;
            color: var(--color-primary);
            font-family: 'Courier New', monospace;
            letter-spacing: 4px;
            animation: countdown-pulse 1s ease-in-out infinite;
        }

        .countdown-label { font-size: 12px; text-transform: uppercase; letter-spacing: 3px; color: var(--color-dim); }

        .health-label { font-size: 12px; text-transform: uppercase; letter-spacing: 2px; color: var(--color-dim); margin-bottom: 8px; display: flex; justify-content: space-between; }
        .health-value { color: var(--color-primary); font-weight: bold; }
        .health-bar-container { width: 100%; height: 8px; background: rgba(0,0,0,0.1); border-radius: 4px; overflow: hidden; border: 1px solid rgba(0,0,0,0.2); }
        .health-bar-fill { height: 100%; background: linear-gradient(90deg, rgba(0,0,0,0.6), #000); transition: width 0.3s ease; }
        .critical .health-bar-fill { background: linear-gradient(90deg, #ff0000, #cc0000); }

        #game-over-screen, #win-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30;
            background: rgba(255,255,255,0.98);
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        #game-over-screen.active, #win-screen.active { display: flex; opacity: 1; }
        .game-over-title, .win-title { font-size: 72px; font-weight: 900; text-transform: uppercase; letter-spacing: 8px; margin-bottom: 20px; }
        .game-over-title { animation: shake 0.5s ease-in-out; }
        .win-title { animation: strong-pulse 2s infinite; color: #000; }
        .win-subtitle { font-size: 24px; color: var(--color-dim); margin-bottom: 40px; letter-spacing: 2px; }
        
        .button-group { display: flex; gap: 20px; }
        .restart-btn, .menu-btn-gameover {
            padding: 16px 40px;
            font-size: 18px;
            background: transparent;
            color: var(--color-primary);
            border: 2px solid var(--color-primary);
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s ease;
        }
        .restart-btn:hover, .menu-btn-gameover:hover { background: var(--color-primary); color: white; }

        .damage-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255,0,0,0.2) 0%, transparent 70%);
            z-index: 4;
            opacity: 0;
            pointer-events: none;
        }
        .damage-flash.active { opacity: 1; animation: flash 0.3s ease; }
        @keyframes flash { 0% { opacity: 0; } 50% { opacity: 1; } 100% { opacity: 0; } }

        #muteBtn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(255,255,255,0.9);
            border: 2px solid rgba(0,0,0,0.3);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #muteBtn:hover { transform: scale(1.1); border-color: #000; }

        @media (max-width: 768px) {
            .game-title { font-size: 48px; }
            .boost-grid { flex-direction: column; gap: 15px; }
            .boost-card { width: 250px; padding: 20px; }
        }

        body { cursor: crosshair; }
        .menu-btn, .back-btn, .restart-btn, .menu-btn-gameover, .boost-card { cursor: pointer; }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="damageFlash" class="damage-flash"></div>
        
        <button id="muteBtn">ðŸ”Š</button>
        
        <div id="main-menu">
            <div class="menu-header">
                <h1 class="game-title">AVOIDE</h1>
                <p class="game-subtitle">Kelompok 3</p>
            </div>
            <div class="menu-buttons">
                <button class="menu-btn" id="playBtn">Mulai Permainan</button>
                <button class="menu-btn" id="boostBtn">Pilih Boost</button>
                <div class="boost-selected-display" id="selectedBoostDisplay">
                    Boost Aktif: <span id="selectedBoostName">Tidak Ada</span>
                </div>
                <button class="menu-btn" id="creditsBtn">Anggota</button>
            </div>
        </div>

        <div id="credits-screen">
            <h2 class="screen-title">Anggota Kelompok</h2>
            <div class="credits-list" style="text-align: center;">
                <div class="credit-member" style="font-size: 24px; margin: 15px 0; animation: fade-in 0.5s forwards;">
                    Danis<span class="credit-role" style="display: block; font-size: 14px; color: #666;">Logika & Algoritma</span>
                </div>
                <div class="credit-member" style="font-size: 24px; margin: 15px 0; animation: fade-in 0.5s 0.1s forwards; opacity: 0;">
                    Dipta<span class="credit-role" style="display: block; font-size: 14px; color: #666;">Playtester</span>
                </div>
                <div class="credit-member" style="font-size: 24px; margin: 15px 0; animation: fade-in 0.5s 0.2s forwards; opacity: 0;">
                    Risky<span class="credit-role" style="display: block; font-size: 14px; color: #666;">Member</span>
                </div>
                <div class="credit-member" style="font-size: 24px; margin: 15px 0; animation: fade-in 0.5s 0.3s forwards; opacity: 0;">
                    Airlangga<span class="credit-role" style="display: block; font-size: 14px; color: #666;">Member</span>
                </div>
                <div class="credit-member" style="font-size: 24px; margin: 15px 0; animation: fade-in 0.5s 0.4s forwards; opacity: 0;">
                    Bilal<span class="credit-role" style="display: block; font-size: 14px; color: #666;">Member</span>
                </div>
            </div>
            <button class="back-btn" id="backFromCredits" style="margin-top: 30px;">Kembali</button>
        </div>

        <div id="boost-screen">
            <h2 class="screen-title">Pilih Boost</h2>
            <div class="boost-grid">
                <div class="boost-card" data-boost="health" id="boostHealth">
                    <div class="boost-icon">â™¥</div>
                    <div class="boost-name">Health</div>
                    <div class="boost-desc">Heal 100% HP<br>Cooldown: 7 detik</div>
                </div>
                <div class="boost-card" data-boost="speed" id="boostSpeed">
                    <div class="boost-icon">âš¡</div>
                    <div class="boost-name">Speed</div>
                    <div class="boost-desc">2.5x Kecepatan<br>Durasi: 5s | CD: 10s</div>
                </div>
                <div class="boost-card" data-boost="invincible" id="boostInvincible">
                    <div class="boost-icon">â™ </div>
                    <div class="boost-name">Invincible</div>
                    <div class="boost-desc">Kebal Damage<br>Durasi: 5s | CD: 10s</div>
                </div>
            </div>
            <div style="font-size: 16px; color: #666; margin-bottom: 20px;">Tekan [E] saat permainan untuk menggunakan</div>
            <button class="back-btn" id="backFromBoost">Kembali ke Menu</button>
        </div>

        <div id="game-ui">
            <div class="hud-panel health-panel glass-panel">
                <div class="health-label">
                    <span>Health</span>
                    <span class="health-value" id="healthText">100%</span>
                </div>
                <div class="health-bar-container">
                    <div class="health-bar-fill" id="healthBarFill" style="width: 100%"></div>
                </div>
            </div>

            <div class="hud-panel countdown-panel">
                <div class="countdown-display" id="countdownTimer">150</div>
                <div class="countdown-label">Detik Tersisa</div>
            </div>

            <div class="hud-panel boost-panel glass-panel" id="boostPanel" style="display: none;">
                <div class="boost-key" id="boostKey">E</div>
                <div class="boost-info">
                    <div class="boost-type" id="boostTypeName">BOOST</div>
                    <div class="boost-status" id="boostStatus">Ready</div>
                    <div class="cooldown-bar" id="cooldownBar">
                        <div class="cooldown-fill" id="cooldownFill" style="width: 100%"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="game-over-screen">
            <h2 class="game-over-title">Game Over</h2>
            <div style="font-size: 20px; color: #666; margin-bottom: 30px;">Kamu Kalah!</div>
            <div class="button-group">
                <button class="restart-btn" id="retryBtn">Coba Lagi</button>
                <button class="menu-btn-gameover" id="menuBtnGameOver">Menu Utama</button>
            </div>
        </div>

        <div id="win-screen">
            <h2 class="win-title">You Win</h2>
            <div class="win-subtitle">Kamu Promax!</div>
            <div class="button-group">
                <button class="restart-btn" id="playAgainBtn">Main Lagi</button>
                <button class="menu-btn-gameover" id="menuBtnWin">Halaman Utama</button>
            </div>
        </div>
    </div>

    <script>
        const CONFIG = {
            PLAYER: {
                SIZE: 24,
                MAX_SPEED: 5,
                BOOST_SPEED_MULTIPLIER: 2.5,
                ACCELERATION: 0.8,
                DECELERATION: 0.85,
                MAX_HP: 100,
                DAMAGE_PER_HIT: 20,
                INVINCIBILITY_FRAMES: 60,
                DAMAGE_COOLDOWN: 1000,
                TRAIL_LENGTH: 10,
                COLOR: '#808080'
            },
            BLOCK: {
                SPAWN_RATE: 5,
                MIN_SIZE: 18,
                MAX_SIZE: 32,
                LIFE_TIME: 4000,
                FADE_IN: 400,
                FADE_OUT: 400,
            },
            LASER: {
                SPAWN_RATE: 0.5,
                TELEGRAPH_FRAMES: 40,
                WIDTH: 12,
                ACTIVE_DURATION: 120,
            },
            PROJECTILE_LASER: {
                NORMAL_RATE: 0.5,
                BOSS_RATE: 1,
                WARNING_DURATION: 800,
                SPEED: 12,
                WIDTH: 14,
                LENGTH: 50,
            },
            BOSS: {
                START_TIME: 70000,
                TOTAL_TIME: 150000,
                LASER_RATE: 1,
                BLOCK_RATE: 10,
                EYE_SIZE: 100,
            },
            BOOST: {
                HEALTH: { HEAL_PERCENT: 100, COOLDOWN: 7000 },
                SPEED: { MULTIPLIER: 2.5, DURATION: 5000, COOLDOWN: 10000 },
                INVINCIBLE: { DURATION: 5000, COOLDOWN: 10000 }
            },
            HEALTH_BOOST: {
                SPAWN_MIN_TIME: 6000,
                SPAWN_MAX_TIME: 10000,
                HEAL_AMOUNT: 20,
                DESPAWN_TIME: 5000,
                SIZE: 15,
            },
            COLORS: {
                BACKGROUND: '#ffffff',
                GRID: 'rgba(0, 0, 0, 0.05)',
                PLAYER: '#808080',
                PLAYER_EYE: '#ffffff'
            }
        };

        class Vector2 {
            constructor(x = 0, y = 0) { this.x = x; this.y = y; }
            add(v) { return new Vector2(this.x + v.x, this.y + v.y); }
            sub(v) { return new Vector2(this.x - v.x, this.y - v.y); }
            mult(s) { return new Vector2(this.x * s, this.y * s); }
            mag() { return Math.sqrt(this.x**2 + this.y**2); }
            normalize() { const m = this.mag(); return m === 0 ? new Vector2(0,0) : new Vector2(this.x/m, this.y/m); }
            copy() { return new Vector2(this.x, this.y); }
            distance(v) { return Math.sqrt((this.x-v.x)**2 + (this.y-v.y)**2); }
        }

        const Utils = {
            randomRange: (min, max) => Math.random() * (max - min) + min,
            randomInt: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min,
            clamp: (value, min, max) => Math.max(min, Math.min(max, value)),
            checkCircleCollision: (c1, c2) => Math.sqrt((c1.x-c2.x)**2 + (c1.y-c2.y)**2) < c1.radius + c2.radius,
            rectCircleCollision: (rect, circle) => {
                const distX = Math.abs(circle.x - rect.x - rect.width/2);
                const distY = Math.abs(circle.y - rect.y - rect.height/2);
                if (distX > rect.width/2 + circle.radius || distY > rect.height/2 + circle.radius) return false;
                if (distX <= rect.width/2 || distY <= rect.height/2) return true;
                return (distX-rect.width/2)**2 + (distY-rect.height/2)**2 <= circle.radius**2;
            }
        };

        // =====================================================
        // AUDIO SYSTEM (SFX hanya saat CLICK, bukan hover)
        // =====================================================
        class AudioSystem {
            constructor() { 
                this.ctx = null; 
                this.enabled = true; 
                this.sfxVolume = 0.3;
                this.bgmVolume = 0.4;
                this.crossfadeDuration = 2000;
                
                // BGM Elements
                this.bgmMenu = document.getElementById('bgmMenu');
                this.bgmNormal = document.getElementById('bgmNormal');
                this.bgmBoss = document.getElementById('bgmBoss');
                this.currentBGM = null;
                this.isMuted = false;
                this.transitioning = false;
                
                // SFX Element (hanya click)
                this.sfxClick = document.getElementById('sfxClick');
            }
            
            init() { 
                try { 
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)(); 
                } catch(e) {} 
                
                [this.bgmMenu, this.bgmNormal, this.bgmBoss].forEach(bgm => {
                    if(bgm) bgm.volume = 0;
                });
            }
            
            switchBGM(targetType) {
                if(this.isMuted || this.transitioning) return;
                
                const targetMap = {
                    'menu': this.bgmMenu,
                    'normal': this.bgmNormal,
                    'boss': this.bgmBoss
                };
                
                const toBGM = targetMap[targetType];
                if(!toBGM || this.currentBGM === toBGM) return;
                
                this.transitioning = true;
                const fromBGM = this.currentBGM;
                const fadeSteps = 60;
                const stepDuration = this.crossfadeDuration / fadeSteps;
                let currentStep = 0;
                
                toBGM.volume = 0;
                toBGM.currentTime = 0;
                const playPromise = toBGM.play();
                if(playPromise) playPromise.catch(e => console.log("Audio play failed:", e));
                
                const fadeInterval = setInterval(() => {
                    currentStep++;
                    const progress = currentStep / fadeSteps;
                    const easeProgress = progress * progress * (3 - 2 * progress);
                    
                    if(fromBGM) fromBGM.volume = this.bgmVolume * (1 - easeProgress);
                    toBGM.volume = this.bgmVolume * easeProgress;
                    
                    if(currentStep >= fadeSteps) {
                        clearInterval(fadeInterval);
                        if(fromBGM) {
                            fromBGM.pause();
                            fromBGM.currentTime = 0;
                        }
                        toBGM.volume = this.bgmVolume;
                        this.currentBGM = toBGM;
                        this.transitioning = false;
                    }
                }, stepDuration);
            }
            
            stopAllBGM() {
                [this.bgmMenu, this.bgmNormal, this.bgmBoss].forEach(bgm => {
                    if(bgm) {
                        bgm.pause();
                        bgm.currentTime = 0;
                    }
                });
                this.currentBGM = null;
            }
            
            // SFX hanya untuk click
            playClickSound() {
                if(this.isMuted) return;
                if(this.sfxClick) {
                    this.sfxClick.currentTime = 0;
                    this.sfxClick.volume = this.sfxVolume;
                    this.sfxClick.play().catch(e => {});
                }
            }
            
            playSound(type, freq, duration) {
                if (!this.ctx || !this.enabled || this.isMuted) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(this.sfxVolume, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }
            
            toggleMute() {
                this.isMuted = !this.isMuted;
                const btn = document.getElementById('muteBtn');
                if(btn) btn.textContent = this.isMuted ? 'ðŸ”‡' : 'ðŸ”Š';
                
                if(this.isMuted) {
                    this.stopAllBGM();
                } else {
                    if(game.state === 'menu') this.switchBGM('menu');
                    else if(game.state === 'playing') this.switchBGM('normal');
                    else if(game.state === 'boss_fight' || game.state === 'boss_transition') this.switchBGM('boss');
                }
            }
            
            playLaserSpawn() { this.playSound('sawtooth', 800, 0.1); }
            playPlayerHit() { this.playSound('square', 100, 0.3); }
            playHealthPickup() { this.playSound('sine', 600, 0.3); }
            playButtonClick() { this.playClickSound(); } // Gunakan MP3 click
            playBossAppear() { this.playSound('sawtooth', 150, 1); }
            playBoostActivate() { 
                if(!this.ctx) return;
                [523.25, 659.25, 783.99].forEach((f, i) => 
                    setTimeout(() => this.playSound('sine', f, 0.3), i*50)
                );
            }
        }

        class Particle {
            constructor(x, y, vx, vy, life, size, color) {
                this.pos = new Vector2(x, y); this.vel = new Vector2(vx, vy);
                this.life = life; this.maxLife = life; this.size = size; this.color = color; this.alpha = 1;
            }
            update() { this.pos = this.pos.add(this.vel); this.vel = this.vel.mult(0.98); this.life--; this.alpha = this.life/this.maxLife; }
            draw(ctx) { ctx.save(); ctx.globalAlpha = this.alpha; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.size, 0, Math.PI*2); ctx.fill(); ctx.restore();}
            isDead() { return this.life <= 0; }
        }

        class ParticleSystem {
            constructor() { this.particles = []; }
            spawnExplosion(x, y, count, color, speed=3) {
                for(let i=0; i<count; i++) {
                    const angle = (Math.PI*2/count)*i + Math.random()*0.5;
                    const vel = new Vector2(Math.cos(angle)*Utils.randomRange(1,speed), Math.sin(angle)*Utils.randomRange(1,speed));
                    this.particles.push(new Particle(x, y, vel.x, vel.y, Utils.randomInt(20,40), Utils.randomRange(2,4), color));
                }
            }
            spawnTrail(x, y, color) { 
                const vel = new Vector2(Utils.randomRange(-0.5,0.5), Utils.randomRange(-0.5,0.5));
                this.particles.push(new Particle(x, y, vel.x, vel.y, 15, 2, color));
            }
            spawnHitSparks(x, y) { this.spawnExplosion(x, y, 12, '#000000', 5); }
            update() { this.particles = this.particles.filter(p => { p.update(); return !p.isDead(); }); }
            draw(ctx) { this.particles.forEach(p => p.draw(ctx)); }
            clear() { this.particles = []; }
        }

        class Player {
            constructor(x, y) {
                this.pos = new Vector2(x, y); this.vel = new Vector2(0,0);
                this.size = CONFIG.PLAYER.SIZE; this.hp = CONFIG.PLAYER.MAX_HP; this.maxHp = CONFIG.PLAYER.MAX_HP;
                this.invincible = false; this.invincibleTimer = 0; this.lastDamageTime = 0;
                this.trail = []; this.angle = 0;
                this.selectedBoost = null;
                this.boostCooldownEnd = 0;
                this.boostActiveEnd = 0;
                this.isBoostActive = false;
                this.normalMaxSpeed = CONFIG.PLAYER.MAX_SPEED;
            }

            update(input, canvasWidth, canvasHeight, currentTime) {
                let acc = new Vector2(0,0);
                if(input.keys['KeyW'] || input.keys['ArrowUp']) acc.y -= CONFIG.PLAYER.ACCELERATION;
                if(input.keys['KeyS'] || input.keys['ArrowDown']) acc.y += CONFIG.PLAYER.ACCELERATION;
                if(input.keys['KeyA'] || input.keys['ArrowLeft']) acc.x -= CONFIG.PLAYER.ACCELERATION;
                if(input.keys['KeyD'] || input.keys['ArrowRight']) acc.x += CONFIG.PLAYER.ACCELERATION;

                if(this.isBoostActive && currentTime > this.boostActiveEnd) {
                    this.deactivateBoost();
                }

                this.vel = this.vel.add(acc);
                if(this.vel.mag() > this.currentMaxSpeed) this.vel = this.vel.normalize().mult(this.currentMaxSpeed);
                if(acc.mag() === 0) this.vel = this.vel.mult(CONFIG.PLAYER.DECELERATION);

                this.pos = this.pos.add(this.vel);
                this.pos.x = Utils.clamp(this.pos.x, this.size, canvasWidth-this.size);
                this.pos.y = Utils.clamp(this.pos.y, this.size, canvasHeight-this.size);

                this.trail.push({pos: this.pos.copy(), alpha: 1});
                if(this.trail.length > CONFIG.PLAYER.TRAIL_LENGTH) this.trail.shift();
                this.trail.forEach((t,i) => t.alpha = i/this.trail.length);

                if(this.invincible && !this.isBoostActive) {
                    this.invincibleTimer--;
                    if(this.invincibleTimer <= 0) this.invincible = false;
                }

                this.angle += this.vel.mag() * 0.05;
            }

            activateBoost(currentTime) {
                if(!this.selectedBoost || currentTime < this.boostCooldownEnd) return false;
                
                this.isBoostActive = true;
                this.boostActiveEnd = currentTime + this.getBoostDuration();
                this.boostCooldownEnd = currentTime + this.getBoostCooldown();

                switch(this.selectedBoost) {
                    case 'health':
                        this.hp = Math.min(this.maxHp, this.hp + this.maxHp);
                        this.isBoostActive = false;
                        break;
                    case 'speed':
                        break;
                    case 'invincible':
                        this.invincible = true;
                        break;
                }
                return true;
            }

            deactivateBoost() {
                this.isBoostActive = false;
                if(this.selectedBoost === 'invincible') {
                    this.invincible = false;
                }
            }

            getBoostDuration() {
                if(this.selectedBoost === 'speed') return CONFIG.BOOST.SPEED.DURATION;
                if(this.selectedBoost === 'invincible') return CONFIG.BOOST.INVINCIBLE.DURATION;
                return 0;
            }

            getBoostCooldown() {
                if(this.selectedBoost === 'health') return CONFIG.BOOST.HEALTH.COOLDOWN;
                if(this.selectedBoost === 'speed') return CONFIG.BOOST.SPEED.COOLDOWN;
                if(this.selectedBoost === 'invincible') return CONFIG.BOOST.INVINCIBLE.COOLDOWN;
                return 0;
            }

            get currentMaxSpeed() { 
                return this.isBoostActive && this.selectedBoost === 'speed' 
                    ? this.normalMaxSpeed * CONFIG.BOOST.SPEED.MULTIPLIER 
                    : this.normalMaxSpeed; 
            }

            takeDamage(amount) {
                const now = Date.now();
                if(now - this.lastDamageTime < CONFIG.PLAYER.DAMAGE_COOLDOWN || (this.invincible && this.isBoostActive)) return false;
                
                this.hp = Math.max(0, this.hp - amount);
                this.invincible = true;
                this.invincibleTimer = CONFIG.PLAYER.INVINCIBILITY_FRAMES;
                this.lastDamageTime = now;
                game.renderer.shakeScreen(10);
                return true;
            }

            heal(amount) { const old = this.hp; this.hp = Math.min(this.maxHp, this.hp+amount); return this.hp > old; }

            draw(ctx) {
                this.trail.forEach((t,i) => {
                    ctx.save(); ctx.globalAlpha = t.alpha*0.3; ctx.fillStyle = this.isBoostActive && this.selectedBoost === 'speed' ? 'rgba(255,215,0,0.3)' : 'rgba(128,128,128,0.3)';
                    ctx.beginPath(); ctx.arc(t.pos.x, t.pos.y, this.size*0.5*(i/this.trail.length), 0, Math.PI*2); ctx.fill(); ctx.restore();
                });

                ctx.save();
                ctx.translate(this.pos.x, this.pos.y); ctx.rotate(this.angle);
                
                if((this.invincible && !this.isBoostActive) && Math.floor(Date.now()/100)%2===0) ctx.globalAlpha = 0.5;
                
                if(this.isBoostActive && this.selectedBoost === 'invincible') {
                    ctx.shadowBlur = 20; ctx.shadowColor = 'rgba(0,255,255,0.8)';
                    ctx.strokeStyle = 'cyan'; ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.arc(0,0,this.size*0.7,0,Math.PI*2); ctx.stroke();
                } else if(this.isBoostActive && this.selectedBoost === 'speed') {
                    ctx.shadowBlur = 15; ctx.shadowColor = 'rgba(255,215,0,0.6)';
                }

                ctx.fillStyle = CONFIG.COLORS.PLAYER;
                ctx.beginPath(); ctx.arc(0,0,this.size/2,0,Math.PI*2); ctx.fill();
                
                ctx.fillStyle = CONFIG.COLORS.PLAYER_EYE;
                ctx.beginPath(); ctx.arc(-6,-4,5,0,Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(6,-4,5,0,Math.PI*2); ctx.fill();
                
                ctx.fillStyle = '#000';
                ctx.beginPath(); ctx.arc(-6,-4,2,0,Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(6,-4,2,0,Math.PI*2); ctx.fill();
                
                ctx.restore();
            }

            getBounds() { const r=this.size/2; return {x:this.pos.x-r, y:this.pos.y-r, width:this.size, height:this.size}; }
        }

        class Enemy {
            constructor(pool) { this.pool=pool; this.active=false; this.pos=new Vector2(0,0); this.vel=new Vector2(0,0); this.rotation=0; this.rotSpeed=0; this.forcedFadeOut=false; this.fadeOutSpeed=0.05; this.alpha=1; }
            spawn(x,y) { this.pos=new Vector2(x,y); this.active=true; this.forcedFadeOut=false; this.alpha=1; this.initialize(); }
            initialize() {}
            update(canvasWidth, canvasHeight) {}
            updateFadeOut() { if(this.forcedFadeOut && this.alpha>0) { this.alpha-=this.fadeOutSpeed; if(this.alpha<=0) { this.alpha=0; this.deactivate(); } } }
            startFadeOut() { this.forcedFadeOut=true; }
            draw(ctx) {}
            deactivate() { this.active=false; }
        }

        class LaserEnemy extends Enemy {
            constructor(pool) { super(pool); this.type='laser'; this.width=CONFIG.LASER.WIDTH; this.length=0; this.angle=0; this.state='warning'; this.timer=0; this.telegraphLength=0; }
            spawnAtPlayer(playerPos, angle=0) { this.pos=playerPos.copy(); this.angle=angle; this.active=true; this.forcedFadeOut=false; this.alpha=1; this.state='warning'; this.timer=CONFIG.LASER.TELEGRAPH_FRAMES; this.length=Math.max(window.innerWidth,window.innerHeight)*1.5; this.telegraphLength=this.length; }
            update() { if(!this.active) return; this.updateFadeOut(); if(this.forcedFadeOut) return; switch(this.state) { case 'warning': this.timer--; if(this.timer<=0) { this.state='active'; this.timer=CONFIG.LASER.ACTIVE_DURATION; game.audio.playLaserSpawn(); } break; case 'active': this.timer--; if(this.timer<=0) { this.state='fading'; this.timer=30; } break; case 'fading': this.timer--; if(this.timer<=0) this.deactivate(); break; } }
            draw(ctx) { if(!this.active) return; ctx.save(); ctx.translate(this.pos.x,this.pos.y); ctx.rotate(this.angle); ctx.globalAlpha=this.alpha; switch(this.state) { case 'warning': const blink=Math.floor(Date.now()/100)%2===0?0.6:0.2; ctx.strokeStyle=`rgba(0,0,0,${blink*this.alpha})`; ctx.lineWidth=2; ctx.setLineDash([10,10]); ctx.beginPath(); ctx.moveTo(-this.telegraphLength/2,0); ctx.lineTo(this.telegraphLength/2,0); ctx.stroke(); break; case 'active': ctx.shadowBlur=20; ctx.shadowColor='rgba(0,0,0,0.5)'; ctx.strokeStyle='#000'; ctx.lineWidth=this.width; ctx.lineCap='round'; ctx.beginPath(); ctx.moveTo(-this.length/2,0); ctx.lineTo(this.length/2,0); ctx.stroke(); ctx.strokeStyle='#333'; ctx.lineWidth=this.width*0.5; ctx.beginPath(); ctx.moveTo(-this.length/2,0); ctx.lineTo(this.length/2,0); ctx.stroke(); break; case 'fading': ctx.globalAlpha=(this.timer/30)*this.alpha; ctx.strokeStyle='#000'; ctx.lineWidth=this.width; ctx.beginPath(); ctx.moveTo(-this.length/2,0); ctx.lineTo(this.length/2,0); ctx.stroke(); break; } ctx.restore(); }
            getHitbox() { if(this.state!=='active' || this.forcedFadeOut) return null; return {type:'line',x:this.pos.x,y:this.pos.y,angle:this.angle,length:this.length,width:this.width}; }
        }

        class ProjectileLaser extends Enemy {
            constructor(pool) { super(pool); this.type='projectile_laser'; this.width=CONFIG.PROJECTILE_LASER.WIDTH; this.length=CONFIG.PROJECTILE_LASER.LENGTH; this.state='warning'; this.timer=0; this.direction=new Vector2(0,0); this.startPos=new Vector2(0,0); this.targetPos=new Vector2(0,0); }
            spawn(targetPos) {
                const side=Utils.randomInt(0,3); const margin=100;
                switch(side) { case 0: this.startPos=new Vector2(Utils.randomRange(0,window.innerWidth),-margin); break; case 1: this.startPos=new Vector2(window.innerWidth+margin,Utils.randomRange(0,window.innerHeight)); break; case 2: this.startPos=new Vector2(Utils.randomRange(0,window.innerWidth),window.innerHeight+margin); break; case 3: this.startPos=new Vector2(-margin,Utils.randomRange(0,window.innerHeight)); break; }
                this.targetPos=targetPos.copy(); this.pos=this.startPos.copy();
                this.direction=targetPos.sub(this.startPos).normalize();
                this.active=true; this.forcedFadeOut=false; this.alpha=1; this.state='warning'; this.timer=CONFIG.PROJECTILE_LASER.WARNING_DURATION/16;
            }
            initialize() {}
            update(canvasWidth,canvasHeight) { if(!this.active) return; this.updateFadeOut(); if(this.forcedFadeOut) return; switch(this.state) { case 'warning': this.timer--; if(this.timer<=0) { this.state='moving'; game.audio.playLaserSpawn(); } break; case 'moving': this.pos=this.pos.add(this.direction.mult(CONFIG.PROJECTILE_LASER.SPEED)); if(this.pos.x<-200||this.pos.x>canvasWidth+200||this.pos.y<-200||this.pos.y>canvasHeight+200) this.deactivate(); break; } }
            drawRoundedRect(ctx,x,y,w,h,r) { ctx.beginPath(); ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r); ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h); ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r); ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y); ctx.closePath(); }
            draw(ctx) { if(!this.active) return; ctx.save(); ctx.globalAlpha=this.alpha; if(this.state==='warning') { const pulse=Math.sin(Date.now()/80)*0.3+0.7; ctx.strokeStyle=`rgba(255,0,0,${pulse*this.alpha})`; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(this.startPos.x,this.startPos.y,25,0,Math.PI*2); ctx.stroke(); ctx.setLineDash([8,8]); ctx.strokeStyle=`rgba(0,0,0,${0.3*this.alpha})`; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(this.startPos.x,this.startPos.y); ctx.lineTo(this.targetPos.x,this.targetPos.y); ctx.stroke(); ctx.setLineDash([]); ctx.strokeStyle=`rgba(255,0,0,${0.5*this.alpha})`; ctx.beginPath(); ctx.arc(this.targetPos.x,this.targetPos.y,15,0,Math.PI*2); ctx.stroke(); } else if(this.state==='moving') { ctx.translate(this.pos.x,this.pos.y); const angle=Math.atan2(this.direction.y,this.direction.x); ctx.rotate(angle); ctx.fillStyle='#000'; ctx.shadowBlur=10; ctx.shadowColor='rgba(0,0,0,0.5)'; this.drawRoundedRect(ctx,-this.length/2,-this.width/2,this.length,this.width,this.width/2); ctx.fill(); ctx.fillStyle='#333'; const cw=this.width*0.6, cl=this.length*0.8; this.drawRoundedRect(ctx,-cl/2,-cw/2,cl,cw,cw/2); ctx.fill(); } ctx.restore(); }
            getHitbox() { if(this.state!=='moving' || this.forcedFadeOut) return null; return {type:'circle',x:this.pos.x,y:this.pos.y,radius:this.width/2}; }
        }

        class BlockEnemy extends Enemy {
            constructor(pool) { super(pool); this.type='block'; this.size=30; this.shape='square'; this.rotSpeed=0; this.lifeTime=0; this.maxLife=0; this.fadeInDuration=0; this.fadeOutDuration=0; this.opacity=0; }
            initialize() { this.size=Utils.randomRange(CONFIG.BLOCK.MIN_SIZE,CONFIG.BLOCK.MAX_SIZE); const shapes=['square','triangle','diamond','pentagon','hexagon','star','cross']; this.shape=shapes[Utils.randomInt(0,shapes.length-1)]; this.rotSpeed=Utils.randomRange(-0.03,0.03); this.rotation=0; this.maxLife=CONFIG.BLOCK.LIFE_TIME+Utils.randomRange(-500,500); this.lifeTime=0; this.fadeInDuration=CONFIG.BLOCK.FADE_IN; this.fadeOutDuration=CONFIG.BLOCK.FADE_OUT; this.opacity=0; const angle=Utils.randomRange(0,Math.PI*2); this.vel=new Vector2(Math.cos(angle),Math.sin(angle)).mult(Utils.randomRange(0.2,0.8)); }
            update(canvasWidth,canvasHeight) { if(!this.active) return; if(this.forcedFadeOut) { this.opacity-=0.05; if(this.opacity<=0) { this.deactivate(); } } else { this.lifeTime+=16; if(this.lifeTime<this.fadeInDuration) { this.opacity=this.lifeTime/this.fadeInDuration; } else if(this.lifeTime>this.maxLife-this.fadeOutDuration) { this.opacity=(this.maxLife-this.lifeTime)/this.fadeOutDuration; } else { this.opacity=1; } if(this.lifeTime>=this.maxLife) { this.deactivate(); return; } } this.pos=this.pos.add(this.vel); this.rotation+=this.rotSpeed; if(this.pos.x<-this.size) this.pos.x=canvasWidth+this.size; if(this.pos.x>canvasWidth+this.size) this.pos.x=-this.size; if(this.pos.y<-this.size) this.pos.y=canvasHeight+this.size; if(this.pos.y>canvasHeight+this.size) this.pos.y=-this.size; }
            drawShape(ctx) { const h=this.size/2, q=this.size/4; switch(this.shape) { case 'square': ctx.rect(-h,-h,this.size,this.size); break; case 'triangle': ctx.moveTo(0,-h); ctx.lineTo(h,h); ctx.lineTo(-h,h); ctx.closePath(); break; case 'diamond': ctx.moveTo(0,-h); ctx.lineTo(h,0); ctx.lineTo(0,h); ctx.lineTo(-h,0); ctx.closePath(); break; case 'pentagon': for(let i=0;i<5;i++) { const a=(i*2*Math.PI/5)-Math.PI/2; const x=Math.cos(a)*h, y=Math.sin(a)*h; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); } ctx.closePath(); break; case 'hexagon': for(let i=0;i<6;i++) { const a=(i*2*Math.PI/6); const x=Math.cos(a)*h, y=Math.sin(a)*h; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); } ctx.closePath(); break; case 'star': for(let i=0;i<10;i++) { const a=(i*Math.PI/5)-Math.PI/2; const r=i%2===0?h:h*0.4; const x=Math.cos(a)*r, y=Math.sin(a)*r; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); } ctx.closePath(); break; case 'cross': ctx.rect(-q,-h,q*2,this.size); ctx.rect(-h,-q,this.size,q*2); break; } }
            draw(ctx) { if(!this.active || this.opacity<=0) return; ctx.save(); ctx.translate(this.pos.x,this.pos.y); ctx.rotate(this.rotation); ctx.globalAlpha=this.alpha*(this.forcedFadeOut?this.alpha:1); const grad=ctx.createRadialGradient(0,0,0,0,0,this.size); grad.addColorStop(0,'#333'); grad.addColorStop(0.5,'#000'); grad.addColorStop(1,'#000'); ctx.fillStyle=grad; ctx.beginPath(); this.drawShape(ctx); ctx.fill(); ctx.strokeStyle='rgba(255,255,255,0.2)'; ctx.lineWidth=1; ctx.stroke(); ctx.restore(); }
            getHitbox() { if(this.forcedFadeOut && this.alpha<0.5) return null; const h=this.size/2; return {type:'rect',x:this.pos.x-h,y:this.pos.y-h,width:this.size,height:this.size}; }
        }

        class OrbEnemy extends Enemy {
            constructor(pool) { super(pool); this.type='orb'; this.radius=12; this.speed=Utils.randomRange(2,4); }
            initialize() { const angle=Utils.randomRange(0,Math.PI*2); this.vel=new Vector2(Math.cos(angle),Math.sin(angle)).mult(this.speed); }
            update(canvasWidth,canvasHeight) { if(!this.active) return; this.updateFadeOut(); if(this.forcedFadeOut) return; this.pos=this.pos.add(this.vel); if(this.pos.x<this.radius || this.pos.x>canvasWidth-this.radius) { this.vel.x*=-1; this.pos.x=Utils.clamp(this.pos.x,this.radius,canvasWidth-this.radius); } if(this.pos.y<this.radius || this.pos.y>canvasHeight-this.radius) { this.vel.y*=-1; this.pos.y=Utils.clamp(this.pos.y,this.radius,canvasHeight-this.radius); } }
            draw(ctx) { if(!this.active) return; ctx.save(); ctx.globalAlpha=this.alpha; ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(this.pos.x,this.pos.y,this.radius,0,Math.PI*2); ctx.fill(); ctx.fillStyle='rgba(255,255,255,0.3)'; ctx.beginPath(); ctx.arc(this.pos.x-3,this.pos.y-3,this.radius*0.3,0,Math.PI*2); ctx.fill(); ctx.restore(); }
            getHitbox() { if(this.forcedFadeOut && this.alpha<0.5) return null; return {type:'circle',x:this.pos.x,y:this.pos.y,radius:this.radius}; }
        }

        class SpikeEnemy extends Enemy {
            constructor(pool) { super(pool); this.type='spike'; this.size=20; this.speed=Utils.randomRange(3,5); }
            initialize() { this.vel=new Vector2(Utils.randomRange(0.5,1)*(Math.random()<0.5?1:-1),Utils.randomRange(0.5,1)*(Math.random()<0.5?1:-1)).normalize().mult(this.speed); }
            update(canvasWidth,canvasHeight) { if(!this.active) return; this.updateFadeOut(); if(this.forcedFadeOut) return; this.pos=this.pos.add(this.vel); if(this.pos.x<-50||this.pos.x>canvasWidth+50||this.pos.y<-50||this.pos.y>canvasHeight+50) this.deactivate(); }
            draw(ctx) { if(!this.active) return; ctx.save(); ctx.globalAlpha=this.alpha; ctx.translate(this.pos.x,this.pos.y); const angle=Math.atan2(this.vel.y,this.vel.x); ctx.rotate(angle); ctx.fillStyle='#000'; ctx.beginPath(); ctx.moveTo(this.size,0); ctx.lineTo(-this.size/2,-this.size/2); ctx.lineTo(-this.size/2,this.size/2); ctx.closePath(); ctx.fill(); ctx.restore(); }
            getHitbox() { if(this.forcedFadeOut && this.alpha<0.5) return null; return {type:'circle',x:this.pos.x,y:this.pos.y,radius:this.size*0.6}; }
        }

        class BossEye {
            constructor() { this.pos=new Vector2(0,0); this.active=false; this.pupilOffset=new Vector2(0,0); this.size=CONFIG.BOSS.EYE_SIZE; this.pupilSize=35; this.laserTimer=0; this.projectileTimer=0; this.blockTimer=0; this.appearProgress=0; }
            spawn(canvasWidth,canvasHeight) { this.pos=new Vector2(canvasWidth/2,canvasHeight+this.size); this.active=true; this.laserTimer=0; this.projectileTimer=0; this.blockTimer=0; this.appearProgress=0; }
            update(playerPos,canvasWidth,canvasHeight,deltaTime) { if(!this.active) return; if(this.appearProgress<1) { this.appearProgress+=0.02; this.pos.y=canvasHeight+this.size-(this.size+150)*this.appearProgress; } const dx=playerPos.x-this.pos.x, dy=playerPos.y-this.pos.y, dist=Math.sqrt(dx*dx+dy*dy), maxOff=this.size*0.25; if(dist>0) { this.pupilOffset.x=(dx/dist)*maxOff; this.pupilOffset.y=(dy/dist)*maxOff; } if(this.appearProgress>=1) { this.laserTimer+=deltaTime; this.projectileTimer+=deltaTime; this.blockTimer+=deltaTime; if(this.laserTimer>=1000) { this.shootLaser(playerPos); this.laserTimer=0; } if(this.projectileTimer>=1000) { this.shootProjectile(playerPos); this.projectileTimer=0; } if(this.blockTimer>=100) { this.spawnBlock(canvasWidth,canvasHeight); this.blockTimer=0; } } }
            shootLaser(playerPos) { const laser=game.spawner.laserPool.get(); const angle=Utils.randomRange(0,Math.PI*2); laser.spawnAtPlayer(playerPos,angle); }
            shootProjectile(playerPos) { const projectile=game.spawner.projectilePool.get(); projectile.spawn(playerPos); }
            spawnBlock(canvasWidth,canvasHeight) { const margin=100; const x=Utils.randomRange(margin,canvasWidth-margin); const y=Utils.randomRange(margin,canvasHeight-margin); const block=game.spawner.blockPool.get(); block.spawn(x,y); }
            draw(ctx) { if(!this.active) return; ctx.save(); ctx.translate(this.pos.x,this.pos.y); ctx.fillStyle='#fff'; ctx.strokeStyle='#000'; ctx.lineWidth=6; ctx.beginPath(); ctx.arc(0,0,this.size,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(this.pupilOffset.x,this.pupilOffset.y,this.pupilSize,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#333'; ctx.beginPath(); ctx.arc(this.pupilOffset.x-10,this.pupilOffset.y-10,this.pupilSize*0.3,0,Math.PI*2); ctx.fill(); ctx.restore(); }
            getHitbox() { return {type:'circle',x:this.pos.x,y:this.pos.y,radius:this.size}; }
            checkCollision(player) { const hitbox=this.getHitbox(), playerCircle={x:player.pos.x,y:player.pos.y,radius:player.size/2}; if(Utils.checkCircleCollision(hitbox,playerCircle)) { if(player.takeDamage(CONFIG.PLAYER.DAMAGE_PER_HIT*2)) { game.particles.spawnHitSparks(player.pos.x,player.pos.y); game.audio.playPlayerHit(); game.ui.showDamageFlash(); } return true; } return false; }
        }

        class HealthBoost {
            constructor() { this.pos=new Vector2(0,0); this.active=false; this.spawnTime=0; this.lifeTime=0; this.size=CONFIG.HEALTH_BOOST.SIZE; this.pulsePhase=0; }
            spawn(x,y) { this.pos=new Vector2(x,y); this.active=true; this.spawnTime=Date.now(); this.lifeTime=CONFIG.HEALTH_BOOST.DESPAWN_TIME; this.pulsePhase=0; }
            update() { if(!this.active) return; if(Date.now()-this.spawnTime>this.lifeTime) { this.active=false; return; } this.pulsePhase+=0.05; }
            draw(ctx) { if(!this.active) return; const pulse=Math.sin(this.pulsePhase)*0.2+1, remaining=1-((Date.now()-this.spawnTime)/this.lifeTime); ctx.save(); ctx.translate(this.pos.x,this.pos.y); ctx.scale(pulse,pulse); ctx.globalAlpha=remaining; ctx.fillStyle='#000'; const w=this.size,h=this.size/3; ctx.fillRect(-w/2,-h/2,w,h); ctx.fillRect(-h/2,-w/2,h,w); ctx.strokeStyle='#000'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,w,0,Math.PI*2); ctx.stroke(); ctx.restore(); }
            getHitbox() { return {type:'circle',x:this.pos.x,y:this.pos.y,radius:this.size}; }
            deactivate() { this.active=false; }
        }

        class ObjectPool {
            constructor(factory,size) { this.factory=factory; this.pool=[]; for(let i=0;i<size;i++) this.pool.push(factory(this)); }
            get() { const obj=this.pool.find(o=>!o.active); if(obj) { obj.active=true; obj.forcedFadeOut=false; obj.alpha=1; return obj; } const newObj=this.factory(this); newObj.active=true; this.pool.push(newObj); return newObj; }
            getActive() { return this.pool.filter(o=>o.active); }
            clear() { this.pool.forEach(o=>o.deactivate()); }
            startFadeOutAll() { this.pool.forEach(o=>{ if(o.active) o.startFadeOut(); }); }
        }

        class SpawnManager {
            constructor(game) { this.game=game; this.lastBlockSpawnTime=0; this.lastLaserSpawnTime=0; this.lastProjectileTime=0; this.blockInterval=1000/CONFIG.BLOCK.SPAWN_RATE; this.laserInterval=1000/CONFIG.LASER.SPAWN_RATE; this.projectileInterval=1000/CONFIG.PROJECTILE_LASER.NORMAL_RATE; this.healthBoostTimer=0; this.laserPool=new ObjectPool((pool)=>new LaserEnemy(pool),10); this.projectilePool=new ObjectPool((pool)=>new ProjectileLaser(pool),15); this.blockPool=new ObjectPool((pool)=>new BlockEnemy(pool),20); this.orbPool=new ObjectPool((pool)=>new OrbEnemy(pool),20); this.spikePool=new ObjectPool((pool)=>new SpikeEnemy(pool),15); this.healthBoost=new HealthBoost(); this.boss=new BossEye(); this.bossMode=false; }
            update(deltaTime,canvasWidth,canvasHeight,player) { const now=Date.now(); if(!this.bossMode) { if(now-this.lastBlockSpawnTime>this.blockInterval) { this.spawnBlock(canvasWidth,canvasHeight); this.lastBlockSpawnTime=now; } if(now-this.lastLaserSpawnTime>this.laserInterval) { this.spawnLaser(player); this.lastLaserSpawnTime=now; } if(now-this.lastProjectileTime>this.projectileInterval) { this.spawnProjectile(player); this.lastProjectileTime=now; } if(Math.random()<0.01) this.spawnRandomEnemy(canvasWidth,canvasHeight); } else { this.boss.update(player.pos,canvasWidth,canvasHeight,deltaTime); this.boss.checkCollision(player); } this.laserPool.getActive().forEach(e=>e.update()); this.projectilePool.getActive().forEach(e=>e.update(canvasWidth,canvasHeight)); this.blockPool.getActive().forEach(e=>e.update(canvasWidth,canvasHeight)); this.orbPool.getActive().forEach(e=>e.update(canvasWidth,canvasHeight)); this.spikePool.getActive().forEach(e=>e.update(canvasWidth,canvasHeight)); const boostInterval=this.bossMode?10000:Utils.randomRange(4000,8000); this.healthBoostTimer+=deltaTime; if(!this.healthBoost.active && this.healthBoostTimer>boostInterval) { this.spawnHealthBoost(canvasWidth,canvasHeight); this.healthBoostTimer=0; } if(this.healthBoost.active) this.healthBoost.update(); }
            startBossMode(canvasWidth,canvasHeight) { this.bossMode=true; this.laserPool.startFadeOutAll(); this.projectilePool.startFadeOutAll(); this.blockPool.startFadeOutAll(); this.orbPool.startFadeOutAll(); this.spikePool.startFadeOutAll(); setTimeout(()=>{ this.boss.spawn(canvasWidth,canvasHeight); game.audio.playBossAppear(); },1000); }
            spawnBlock(canvasWidth,canvasHeight) { const margin=100; const x=Utils.randomRange(margin,canvasWidth-margin); const y=Utils.randomRange(margin,canvasHeight-margin); const block=this.blockPool.get(); block.spawn(x,y); }
            spawnLaser(player) { const laser=this.laserPool.get(); const angle=Utils.randomRange(0,Math.PI*2); laser.spawnAtPlayer(player.pos,angle); }
            spawnProjectile(player) { const projectile=this.projectilePool.get(); projectile.spawn(player.pos); }
            spawnRandomEnemy(canvasWidth,canvasHeight) { const types=['orb','spike']; const type=types[Utils.randomInt(0,types.length-1)]; if(type==='orb') { const x=Utils.randomRange(50,canvasWidth-50); const y=Utils.randomRange(50,canvasHeight-50); this.orbPool.get().spawn(x,y); } else { const x=Math.random()<0.5?-30:canvasWidth+30; const y=Utils.randomRange(0,canvasHeight); this.spikePool.get().spawn(x,y); } }
            spawnHealthBoost(canvasWidth,canvasHeight) { const x=Utils.randomRange(100,canvasWidth-100); const y=Utils.randomRange(100,canvasHeight-100); this.healthBoost.spawn(x,y); }
            draw(ctx) { if(this.bossMode) this.boss.draw(ctx); this.laserPool.getActive().forEach(e=>e.draw(ctx)); this.projectilePool.getActive().forEach(e=>e.draw(ctx)); this.blockPool.getActive().forEach(e=>e.draw(ctx)); this.spikePool.getActive().forEach(e=>e.draw(ctx)); this.orbPool.getActive().forEach(e=>e.draw(ctx)); this.healthBoost.draw(ctx); }
            checkCollisions(player) { const allEnemies=[...this.laserPool.getActive(),...this.projectilePool.getActive(),...this.orbPool.getActive(),...this.blockPool.getActive(),...this.spikePool.getActive()]; const playerCircle={x:player.pos.x,y:player.pos.y,radius:player.size/2}; allEnemies.forEach(enemy=>{ const hitbox=enemy.getHitbox(); if(!hitbox) return; let collision=false; if(hitbox.type==='circle') collision=Utils.checkCircleCollision(playerCircle,hitbox); else if(hitbox.type==='rect') collision=Utils.rectCircleCollision(hitbox,playerCircle); else if(hitbox.type==='line') { const cos=Math.cos(hitbox.angle), sin=Math.sin(hitbox.angle), dx=player.pos.x-hitbox.x, dy=player.pos.y-hitbox.y, localX=dx*cos+dy*sin, localY=-dx*sin+dy*cos; if(Math.abs(localX)<hitbox.length/2 && Math.abs(localY)<hitbox.width/2+playerCircle.radius) collision=true; } if(collision && player.takeDamage(CONFIG.PLAYER.DAMAGE_PER_HIT)) { game.particles.spawnHitSparks(player.pos.x,player.pos.y); game.audio.playPlayerHit(); game.ui.showDamageFlash(); } }); if(this.healthBoost.active) { const hbHitbox=this.healthBoost.getHitbox(); if(Utils.checkCircleCollision(playerCircle,hbHitbox)) { if(player.heal(CONFIG.HEALTH_BOOST.HEAL_AMOUNT)) { this.healthBoost.deactivate(); game.audio.playHealthPickup(); game.particles.spawnExplosion(this.healthBoost.pos.x,this.healthBoost.pos.y,20,'#000000',4); } } } }
            reset() { this.laserPool.clear(); this.projectilePool.clear(); this.orbPool.clear(); this.blockPool.clear(); this.spikePool.clear(); this.healthBoost.active=false; this.boss.active=false; this.bossMode=false; this.lastBlockSpawnTime=0; this.lastLaserSpawnTime=0; this.lastProjectileTime=0; this.healthBoostTimer=0; }
        }

        class InputHandler {
            constructor() { this.keys={}; this.setupListeners(); }
            setupListeners() { window.addEventListener('keydown',(e)=>{ this.keys[e.code]=true; }); window.addEventListener('keyup',(e)=>{ this.keys[e.code]=false; }); }
            isPressed(code) { return !!this.keys[code]; }
        }

        class Renderer {
            constructor(canvas) { this.canvas=canvas; this.ctx=canvas.getContext('2d'); this.resize(); this.shakeAmount=0; this.shakeDecay=0.9; window.addEventListener('resize',()=>this.resize()); }
            resize() { this.canvas.width=window.innerWidth; this.canvas.height=window.innerHeight; }
            shakeScreen(amount) { this.shakeAmount=amount; }
            beginFrame() { this.ctx.save(); if(this.shakeAmount>0.5) { const dx=(Math.random()-0.5)*this.shakeAmount, dy=(Math.random()-0.5)*this.shakeAmount; this.ctx.translate(dx,dy); this.shakeAmount*=this.shakeDecay; } }
            endFrame() { this.ctx.restore(); }
            drawBackground() { const ctx=this.ctx; ctx.fillStyle=CONFIG.COLORS.BACKGROUND; ctx.fillRect(0,0,this.canvas.width,this.canvas.height); ctx.strokeStyle=CONFIG.COLORS.GRID; ctx.lineWidth=1; const gridSize=50; const offsetX=(Date.now()/50)%gridSize, offsetY=(Date.now()/50)%gridSize; for(let x=offsetX; x<this.canvas.width; x+=gridSize) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,this.canvas.height); ctx.stroke(); } for(let y=offsetY; y<this.canvas.height; y+=gridSize) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(this.canvas.width,y); ctx.stroke(); } }
            getContext() { return this.ctx; }
            getDimensions() { return {width:this.canvas.width, height:this.canvas.height}; }
        }

        class UIManager {
            constructor() { 
                this.elements={ 
                    mainMenu:document.getElementById('main-menu'), 
                    creditsScreen:document.getElementById('credits-screen'),
                    boostScreen:document.getElementById('boost-screen'),
                    gameUI:document.getElementById('game-ui'), 
                    gameOverScreen:document.getElementById('game-over-screen'), 
                    winScreen:document.getElementById('win-screen'), 
                    damageFlash:document.getElementById('damageFlash'), 
                    healthBarFill:document.getElementById('healthBarFill'), 
                    healthText:document.getElementById('healthText'), 
                    countdownTimer:document.getElementById('countdownTimer'),
                    selectedBoostDisplay:document.getElementById('selectedBoostDisplay'),
                    selectedBoostName:document.getElementById('selectedBoostName'),
                    boostPanel:document.getElementById('boostPanel'),
                    boostKey:document.getElementById('boostKey'),
                    boostTypeName:document.getElementById('boostTypeName'),
                    boostStatus:document.getElementById('boostStatus'),
                    cooldownBar:document.getElementById('cooldownBar'),
                    cooldownFill:document.getElementById('cooldownFill')
                }; 
                this.selectedBoost=null;
                this.setupEventListeners(); 
            }
            
            setupEventListeners() { 
                // Helper untuk attach sound HANYA saat CLICK (tidak hover)
                const addClickSound = (id) => {
                    const btn = document.getElementById(id);
                    if(btn) {
                        btn.addEventListener('click', () => game.audio.playButtonClick());
                    }
                };

                // Main Menu Buttons
                addClickSound('playBtn');
                addClickSound('boostBtn');
                addClickSound('creditsBtn');
                
                document.getElementById('playBtn').addEventListener('click',()=> this.startGameTransition());
                document.getElementById('creditsBtn').addEventListener('click',()=> this.showCredits());
                document.getElementById('boostBtn').addEventListener('click',()=> this.showBoostScreen());

                // Credits Screen
                addClickSound('backFromCredits');
                document.getElementById('backFromCredits').addEventListener('click',()=> this.hideCredits());

                // Boost Screen
                addClickSound('backFromBoost');
                document.getElementById('backFromBoost').addEventListener('click',()=> this.hideBoostScreen());
                
                // Boost Cards (hanya click yang ada suara)
                document.querySelectorAll('.boost-card').forEach(card => {
                    card.addEventListener('click',(e)=>{ 
                        game.audio.playButtonClick(); // SFX click di sini
                        const boostType=card.dataset.boost;
                        this.selectBoost(boostType);
                    });
                });

                // Game Over / Win Screen
                addClickSound('retryBtn');
                addClickSound('menuBtnGameOver');
                addClickSound('playAgainBtn');
                addClickSound('menuBtnWin');
                
                document.getElementById('retryBtn').addEventListener('click',()=> this.retryGame());
                document.getElementById('menuBtnGameOver').addEventListener('click',()=> this.returnToMenu());
                document.getElementById('playAgainBtn').addEventListener('click',()=> this.retryGame());
                document.getElementById('menuBtnWin').addEventListener('click',()=> this.returnToMenu());

                // Mute Button
                document.getElementById('muteBtn').addEventListener('click', () => game.audio.toggleMute());
            }
            
            selectBoost(type) {
                this.selectedBoost=type;
                document.querySelectorAll('.boost-card').forEach(c=>c.classList.remove('selected'));
                document.getElementById('boost'+type.charAt(0).toUpperCase()+type.slice(1)).classList.add('selected');
                
                const names={health:'Health Regen', speed:'Speed Boost', invincible:'Invincibility'};
                this.elements.selectedBoostName.textContent=names[type];
                if(game.player) game.player.selectedBoost=type;
            }
            
            showBoostScreen() { this.elements.boostScreen.classList.add('active'); }
            hideBoostScreen() { this.elements.boostScreen.classList.remove('active'); }
            showMainMenu() { this.elements.mainMenu.classList.remove('hidden'); this.elements.gameUI.classList.remove('active'); this.elements.gameOverScreen.classList.remove('active'); this.elements.winScreen.classList.remove('active'); }
            hideMainMenu() { this.elements.mainMenu.classList.add('hidden'); }
            showCredits() { this.elements.creditsScreen.classList.add('active'); }
            hideCredits() { this.elements.creditsScreen.classList.remove('active'); }
            
            startGameTransition() { 
                const title=document.querySelector('.game-title'), subtitle=document.querySelector('.game-subtitle');
                title.style.transition='all 1s ease'; subtitle.style.transition='all 1s ease';
                title.style.transform='translate(35vw,-35vh) scale(0.5)'; title.style.opacity='0.3';
                subtitle.style.transform='translate(35vw,-35vh) scale(0.5)'; subtitle.style.opacity='0';
                document.querySelector('.menu-buttons').style.opacity='0';
                setTimeout(()=>{
                    this.hideMainMenu(); 
                    this.elements.gameUI.classList.add('active'); 
                    game.start();
                    setTimeout(()=>{
                        title.style.transform=''; title.style.opacity=''; title.style.transition='';
                        subtitle.style.transform=''; subtitle.style.opacity=''; subtitle.style.transition='';
                        document.querySelector('.menu-buttons').style.opacity='';
                    },1000);
                },800); 
            }
            
            updateHealth(hp,maxHp) { 
                const percent=(hp/maxHp)*100; 
                this.elements.healthBarFill.style.width=`${percent}%`; 
                this.elements.healthText.textContent=`${Math.ceil(hp)}%`; 
                document.querySelector('.health-panel').classList.toggle('critical', percent<=30);
            }
            
            updateCountdown(seconds) { 
                this.elements.countdownTimer.textContent=Math.max(0,Math.ceil(seconds)); 
                this.elements.countdownTimer.style.color=seconds<=10?'#ff0000':'#000';
            }
            
            updateBoostUI(player, currentTime) {
                if(!player.selectedBoost) {
                    this.elements.boostPanel.style.display='none';
                    return;
                }
                this.elements.boostPanel.style.display='flex';
                
                const names={health:'HEALTH', speed:'SPEED', invincible:'SHIELD'};
                this.elements.boostTypeName.textContent=names[player.selectedBoost];
                
                const isReady=currentTime>=player.boostCooldownEnd;
                const isActive=player.isBoostActive && currentTime<player.boostActiveEnd;
                
                if(isActive) {
                    this.elements.boostKey.className='boost-key ready';
                    this.elements.boostStatus.textContent='ACTIVE';
                    this.elements.boostStatus.style.color='green';
                    const duration=player.getBoostDuration();
                    const elapsed=currentTime-(player.boostActiveEnd-duration);
                    const pct=Math.max(0,100-(elapsed/duration*100));
                    this.elements.cooldownFill.style.width=pct+'%';
                } else if(isReady) {
                    this.elements.boostKey.className='boost-key ready';
                    this.elements.boostStatus.textContent='READY (Press E)';
                    this.elements.boostStatus.style.color='green';
                    this.elements.cooldownFill.style.width='100%';
                } else {
                    this.elements.boostKey.className='boost-key cooldown';
                    this.elements.boostStatus.textContent='COOLDOWN';
                    this.elements.boostStatus.style.color='red';
                    const cooldown=player.getBoostCooldown();
                    const elapsed=currentTime-(player.boostCooldownEnd-cooldown);
                    const pct=Math.max(0,100-(elapsed/cooldown*100));
                    this.elements.cooldownFill.style.width=pct+'%';
                }
            }
            
            showDamageFlash() { this.elements.damageFlash.classList.add('active'); setTimeout(()=>this.elements.damageFlash.classList.remove('active'),300); }
            showGameOver() { this.elements.gameOverScreen.classList.add('active'); }
            showWin() { this.elements.winScreen.classList.add('active'); }
            retryGame() { this.elements.gameOverScreen.classList.remove('active'); this.elements.winScreen.classList.remove('active'); game.restart(); }
            returnToMenu() { this.elements.gameOverScreen.classList.remove('active'); this.elements.winScreen.classList.remove('active'); game.returnToMenu(); }
        }

        class Game {
            constructor() { 
                this.canvas=document.getElementById('gameCanvas'); 
                this.renderer=new Renderer(this.canvas); 
                this.input=new InputHandler(); 
                this.audio=new AudioSystem(); 
                this.ui=new UIManager(); 
                this.particles=new ParticleSystem(); 
                this.spawner=new SpawnManager(this); 
                this.state='menu'; 
                this.player=null; 
                this.lastTime=0; 
                this.accumulator=0; 
                this.timeStep=1000/60; 
                this.gameTimer=0; 
                this.bossStarted=false; 
                
                this.audio.init();
                this.audio.switchBGM('menu');
                
                this.loop=this.loop.bind(this); 
                requestAnimationFrame(this.loop); 
            }
            
            start() { 
                this.audio.switchBGM('normal');
                const dims=this.renderer.getDimensions(); 
                this.player=new Player(dims.width/2,dims.height/2); 
                this.player.selectedBoost=this.ui.selectedBoost;
                this.spawner.reset(); 
                this.particles.clear(); 
                this.gameTimer=0; 
                this.bossStarted=false; 
                this.state='playing'; 
            }
            
            restart() { this.start(); }
            
            returnToMenu() { 
                this.state='menu'; 
                this.audio.switchBGM('menu');
                this.ui.showMainMenu(); 
            }
            
            startBossMode() { 
                this.state='boss_transition'; 
                this.audio.switchBGM('boss');
                this.spawner.startBossMode(this.renderer.canvas.width,this.renderer.canvas.height); 
                setTimeout(()=>this.state='boss_fight',2000); 
            }
            
            win() { 
                this.state='win'; 
                this.ui.showWin(); 
                this.audio.stopAllBGM();
                this.renderer.shakeScreen(5); 
                for(let i=0; i<5; i++) {
                    setTimeout(() => this.particles.spawnExplosion(
                        Utils.randomRange(100,this.renderer.canvas.width-100),
                        Utils.randomRange(100,this.renderer.canvas.height-100),
                        30,'#000000',6
                    ),i*200);
                }
            }
            
            gameOver() { 
                this.state='gameover'; 
                this.ui.showGameOver(); 
                this.audio.stopAllBGM();
                this.renderer.shakeScreen(20); 
                if(this.player) {
                    this.particles.spawnExplosion(this.player.pos.x,this.player.pos.y,50,'#000000',8);
                }
            }
            
            update(deltaTime) { 
                if(this.state==='menu'||this.state==='gameover'||this.state==='win') return; 
                const{width,height}=this.renderer.getDimensions(); 
                this.gameTimer+=deltaTime; 
                const remainingSeconds=(CONFIG.BOSS.TOTAL_TIME-this.gameTimer)/1000; 
                this.ui.updateCountdown(remainingSeconds); 
                
                if(this.input.isPressed('KeyE')) {
                    if(this.player && this.player.selectedBoost && this.player.activateBoost(Date.now())) {
                        this.audio.playBoostActivate();
                    }
                }
                
                if(this.gameTimer>=CONFIG.BOSS.TOTAL_TIME) { 
                    if(this.player.hp>0) { this.win(); return; } 
                } 
                if(!this.bossStarted && this.gameTimer>=CONFIG.BOSS.START_TIME) { 
                    this.bossStarted=true; this.startBossMode(); 
                } 
                this.player.update(this.input,width,height,Date.now()); 
                this.spawner.update(deltaTime,width,height,this.player); 
                this.particles.update(); 
                if(this.player.vel.mag()>0.1) { 
                    const trailCount=Math.floor(this.player.vel.mag()); 
                    for(let i=0;i<trailCount;i++) this.particles.spawnTrail(this.player.pos.x+Utils.randomRange(-5,5),this.player.pos.y+Utils.randomRange(-5,5),'rgba(128,128,128,0.3)'); 
                } 
                this.spawner.checkCollisions(this.player); 
                if(this.player.hp<=0) this.gameOver(); 
                this.ui.updateHealth(this.player.hp,this.player.maxHp); 
                this.ui.updateBoostUI(this.player,Date.now());
            }
            
            draw() { 
                this.renderer.drawBackground(); 
                this.renderer.beginFrame(); 
                const ctx=this.renderer.getContext(); 
                if(this.player && (this.state==='playing'||this.state==='boss_transition'||this.state==='boss_fight')) { 
                    this.spawner.draw(ctx); 
                    this.particles.draw(ctx); 
                    this.player.draw(ctx); 
                    if(this.state==='boss_transition') { 
                        ctx.fillStyle='#000'; 
                        ctx.font='bold 48px Arial'; 
                        ctx.textAlign='center'; 
                        ctx.fillText('BOSS APPROACHING...',this.renderer.canvas.width/2,this.renderer.canvas.height/2); 
                    } 
                } 
                this.renderer.endFrame(); 
            }
            
            loop(timestamp) { 
                const deltaTime=timestamp-this.lastTime; 
                this.lastTime=timestamp; 
                this.accumulator+=deltaTime; 
                while(this.accumulator>=this.timeStep) { 
                    this.update(this.timeStep); 
                    this.accumulator-=this.timeStep; 
                } 
                this.draw(); 
                requestAnimationFrame(this.loop); 
            }
        }

        const game=new Game();
    </script>
</body>
</html>
